/*小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。

在冒泡排序中，每次只能交换相邻的两个元素。

小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符， 则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。

例如，对于字符串 lanlan 排序，只需要 11 次交换。对于字符串 qiaoqiao 排序，总共需要 44 次交换。

小蓝找到了很多字符串试图排序，他恰巧碰到一个字符串，需要 100100 次交 换，可是他忘了吧这个字符串记下来，现在找不到了。

请帮助小蓝找一个只包含小写英文字母且没有字母重复出现的字符串，对 该串的字符排序，正好需要 100100 次交换。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个*/
#include <iostream>
using namespace std;
int main()
{
	//考虑冒泡排序的复杂度，对于拥有N个字母的字符串，最多需要交换N*(N-1)/2次（完全乱序时）
	//易知N=15时，有15*14/2=105，即满足100次交换所需的最短字符串有15个字母。
	//要求字典序最小，那么显然要取a~o这15个字典序最小的字母
	/*
	  逆向思考，目标字符串经过100次交换后，得到正序字符串abcdefghijklmno，而完全逆序的字符串onmlkjihgfedcba变成正序字符串需要105次交换，那么将完全逆序的字符串交换5次后，便能得到答案。
	  而要求字典序最小，那么将j交换5次提到字符串最前面，就得到了最小的情况
	*/
	printf("jonmlkihgfedcba");
	return 0;
}